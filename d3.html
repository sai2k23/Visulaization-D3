<!DOCTYPE html>

<html lang="en">



<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>D3 Temperature & Humidity Chart</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
    }

    h2 {
      text-align: center;
      color: #0b5ed7;
      margin-top: 15px 0;
    }

    .container {
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: flex-start;
      margin: 20px;
      gap: 20px;
    }

    .chart-box {
      flex: 2;
    }

    svg {
      background: #fff;
      border: 1px solid #eee;
    }

    .controls {
      flex: 1;
      border: 1px solid #ddd;
      padding: 15px;
      border-radius: 8px;
      background: #f9f9f9;
      display: flex;
      flex-direction: column;
      gap: 15px;
      max-width: 280px;
    }

    .legend-box {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      cursor: pointer;
    }



    /* LEGEND: Use icons instead of color squares */

    .legend-icon {
      width: 14px;
      height: 14px;
      font-size: 14px;
      line-height: 14px;
      text-align: center;
    }



    .legend-item.inactive {
      opacity: 0.5;
    }

    .time-buttons {
      display: flex;
      flex-direction: row;
      gap: 10px;
      justify-content: space-evenly;
    }

    .time-buttons button {
      width: 55px;
      height: 28px;
      border: 2px solid #0b5ed7;
      background: white;
      color: #0b5ed7;
      border-radius: 5px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s ease-in-out;
    }

    .time-buttons button.active {
      background: #0b5ed7;
      color: white;
      transform: scale(1.05);
    }

    .time-buttons button:hover {
      background: #0b5ed7;
      color: white;
    }

    .toolbar {
      display: flex;
      flex-direction: row;
      justify-content: space-evenly;
      gap: 8px;
    }

    .toolbar button {
      padding: 6px 8px;
      border: 1px solid #0b5ed7;
      background: white;
      color: #0b5ed7;
      border-radius: 50%;
      cursor: pointer;
      width: 40px;
      height: 40px;
      font-size: 12px;
      font-weight: bold;
    }

    .toolbar button:hover {
      background: #0b5ed7;
      color: white;
    }



    /* tooltip */

    #tooltip {
      position: absolute;
      pointer-events: none;
      background: rgba(0, 0, 0, 0.75);
      color: white;
      padding: 6px 8px;
      border-radius: 4px;
      font-size: 13px;
      opacity: 0;
      transition: opacity 120ms ease;
    }



    /* brush selection */

    .brush .selection {
      fill: rgba(11, 94, 215, 0.2);
      stroke: #0b5ed7;
    }

    /* Cursor styles applied to the SVG node */
    .tooltip-enabled {
      cursor: crosshair;
    }

    .pan-enabled-cursor {
      cursor: grab !important;
    }
  </style>

</head>



<body>
  <div id="tooltip"></div>
  <h2>Line Chart (D3.js)</h2>


  <div class="container">
    <div class="chart-box">
      <div class="time-buttons" id="timeButtons">
        <button data-unit="hour">Hours</button>
        <button data-unit="day" class="active">Days</button>
        <button data-unit="week">Week</button>
        <button data-unit="month">Month</button>
        <button data-unit="year">Year</button>
      </div>
      <svg id="chart" width="1050" height="550"></svg>
      <div class="toolbar">
        <button onclick="zoomBy(1.2)">+</button>
        <button onclick="zoomBy(0.8)">-</button>
        <button onclick="resetZoom()">‚ü≥</button>
        <button onclick="downloadSVG()">‚¨áÔ∏è</button>
      </div>
    </div>
    <!-- Controls Sidebar -->
    <div class="controls">
      <div id="date-picker-container" style="padding-bottom: 10px;">
        <label for="dataDate">Date:</label>
        <input type="date" id="dataDate" style="width: 100%; padding: 5px;border: 1px solid #ddd; border-radius: 4px;">
      </div>
      <div id="custom-legend" class="legend-box"></div>
    </div>
  </div>
  </div>

  <script>
    (async () => {
      // --- Setup svg + scales + groups 
      const svg = d3.select("#chart");
      const widthTotal = +svg.attr("width");
      const heightTotal = +svg.attr("height");
      const margin = { top: 50, right: 80, bottom: 80, left: 70 };
      const width = widthTotal - margin.left - margin.right;
      const height = heightTotal - margin.top - margin.bottom;

      const mainG = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
      const xAxisG = mainG.append("g").attr("transform", `translate(0,${height})`);
      const yAxisG = mainG.append("g");
      const y2AxisG = mainG.append("g").attr("transform", `translate(${width},0)`);
      // Chart content wrapper 
      const chartContent = mainG.append("g").attr("class", "chart-content");
      const linesLayer = chartContent.append("g").attr("class", "lines");
      const markersLayer = chartContent.append("g").attr("class", "markers");
      const dotsLayer = chartContent.append("g").attr("class", "dots");



      // Axis labels For Temperatue, Humidity and Dat & Time  

      svg
        .append("text").attr("x", margin.left + width / 2).attr("y", margin.top + height + 75).attr("text-anchor", "middle").attr("fill", "#333").text("Date & Time");
      svg
        .append("text").attr("x", 18).attr("y", margin.top + height / 2).attr("text-anchor", "middle").attr("transform", `rotate(-90,18,${margin.top + height / 2})`).attr("fill", "#333").text("Temperature (¬∞C)");
      svg
        .append("text").attr("x", margin.left + width + 48).attr("y", margin.top + height / 2).attr("text-anchor", "middle").attr("transform", `rotate(-90,${margin.left + width + 48},${margin.top + height / 2})`).attr("fill", "#333").text("Humidity (%)");

      // Scales 
      const x = d3.scaleTime().range([0, width]);
      const y = d3.scaleLinear().range([height, 0]);
      const y2 = d3.scaleLinear().range([height, 0]);

      const colorMap = {
        humidity: "lightgreen",
        room: "steelblue",
        setT: "orange",
        outside: "purple",
        heater: "#0b5ed7",
        override: "orange",
        working: "black"
      };

      // tooltip 
      const tooltip = d3.select("#tooltip");

      // raw data from sources 
      const [records, weather] = await Promise.all([
        fetch("data.json").then(r => r.json()),
        // get outside temperatures for the date range (user previously used this endpoint) 
        fetch(`https://archive-api.open-meteo.com/v1/archive?latitude=55.8642&longitude=-4.2518&start_date=2025-09-04&end_date=2025-09-18&hourly=temperature_2m`).then(r => r.json()).catch(_ => null)
      ]);
      // --- Parse records: assume each record has timestamp (ISO or parseable), room_temp, set_temp, humidity, heating, override, working_hours 
      // normalize timestamps 
      records.forEach(r => {
        // if timestamp is numeric / seconds / ms: try to parse robustly 
        r._ts = new Date(r.timestamp);
        if (Number.isNaN(r._ts.getTime())) {
          // try other keys or assume ISO string 
          r._ts = new Date(String(r.timestamp));
        }
      });



      // prepare outside data from weather (avoid duplication; weather.hourly arrays used directly) 
      const outside = [];
      if (weather && weather.hourly && weather.hourly.time) {
        for (let i = 0; i < weather.hourly.time.length; i++) {
          outside.push({ x: weather.hourly.time[i], y: weather.hourly.temperature_2m[i] });
        }
      }



      // Build arrays for datasets from records 

      const humidity = [], room = [], setT = [], heaterMarkers = [], overrideMarkers = [], workingDots = [];
      // Track heater transitions properly (ON/OFF changes) 
      let lastHeaterState = null;

      for (const r of records) {
        // skip if no timestamp 
        if (!r._ts || isNaN(r._ts.getTime())) continue;
        if (r.humidity !== null && r.humidity !== undefined) humidity.push({ x: r._ts.toISOString(), y: +r.humidity, raw: r });
        if (r.room_temp !== null && r.room_temp !== undefined) room.push({ x: r._ts.toISOString(), y: +r.room_temp, raw: r });
        if (r.set_temp !== null && r.set_temp !== undefined) setT.push({ x: r._ts.toISOString(), y: +r.set_temp, raw: r });

        // heater state changes detection: treat r.heating as truthy "true"/"false" string or boolean 
        const heating = (typeof r.heating === "string") ? (r.heating === "true") : Boolean(r.heating)
        if (lastHeaterState === null) {
          lastHeaterState = heating;
        } else if (heating !== lastHeaterState) {
          // push marker at this timestamp. Use room_temp value if present, else set_temp 
          const yVal = (r.room_temp !== null && r.room_temp !== undefined) ? +r.room_temp : ((r.set_temp !== null && r.set_temp !== undefined) ? +r.set_temp : 0);
          heaterMarkers.push({ x: r._ts.toISOString(), y: yVal, state: heating, raw: r });
          lastHeaterState = heating;
        }
        // override detection (string or boolean) 

        const ov = (typeof r.override === "string") ? (r.override === "true") : Boolean(r.override);
        if (ov) {
          const yVal = (r.room_temp !== null && r.room_temp !== undefined) ? +r.room_temp : ((r.set_temp !== null && r.set_temp !== undefined) ? +r.set_temp : 0);
          overrideMarkers.push({ x: r._ts.toISOString(), y: yVal, raw: r });
        }
        // working hours + heating together (if flag exists) 
        const working = (typeof r.working_hours === "string") ? (r.working_hours === "true") : Boolean(r.working_hours);
        if (working && heating) {
          const yVal = (r.room_temp !== null && r.room_temp !== undefined) ? +r.room_temp : ((r.set_temp !== null && r.set_temp !== undefined) ? +r.set_temp : 0);
          workingDots.push({ x: r._ts.toISOString(), y: yVal, raw: r });
        }
      }



      // --- Helper to convert arrays to d3-friendly sorted arrays 

      function sortByX(a, b) { return new Date(a.x) - new Date(b.x); }
      humidity.sort(sortByX); room.sort(sortByX); setT.sort(sortByX); outside.sort(sortByX);
      heaterMarkers.sort(sortByX); overrideMarkers.sort(sortByX); workingDots.sort(sortByX);

      // detect list of dates available in records (for Hours view default) 
      const recordDates = Array.from(new Set(records.map(r => {
        if (!r._ts || isNaN(r._ts.getTime())) return null;
        const d = new Date(r._ts.getTime()); d.setHours(0, 0, 0, 0);
        return d.toISOString();
      }).filter(Boolean))).sort();
      // default hour day -> first date's day 
      let selectedDayISO = recordDates.length ? recordDates[0] : null;
      const minDate = recordDates.length ? recordDates[0].substring(0, 10) : '';
      const maxDate = recordDates.length ? recordDates[recordDates.length - 1].substring(0, 10) : '';

      // Set min/max attributes on the HTML date input element 
      document.getElementById('dataDate').setAttribute('min', minDate);
      document.getElementById('dataDate').setAttribute('max', maxDate);

      // global visibility map for legend toggles 
      const visibility = { humidity: true, room: true, setT: true, outside: true, heater: true, override: true, working: true };

      // initial x,y domains (full span) 
      const allPoints = [...humidity, ...room, ...setT, ...outside, ...heaterMarkers, ...overrideMarkers, ...workingDots];
      if (!allPoints.length) return;
      x.domain(d3.extent(allPoints, d => new Date(d.x)));

      // primary y domain based on temps + outside 
      y.domain([0, d3.max([...room, ...setT, ...outside], d => d.y) + 2]);
      y2.domain([0, d3.max(humidity, d => d.y) + 5]);

      // --- Axis and Draw Helpers --- 
      let currentXScale = x.copy();
      let isInitialLoad = true; // It checks the intial animation i started it won't repreat again 

      // axis render helper (uses unit and optionally a specific day for HOURS) 
      function renderAxes(unit, dayIso) {
        let currentScale = x;
        if (unit === 'hour' && dayIso) {
          const start = new Date(dayIso); start.setHours(0, 0, 0, 0);
          const end = new Date(start.getTime() + 24 * 3600 * 1000);
          x.domain([start, end]);
        }

        // unit: 'hour','day','week','month','year' 
        let axis;
        if (unit === 'hour') {
          axis = d3.axisBottom(x)
            .ticks(d3.timeHour.every(1))
            .tickFormat(d3.timeFormat(" %b:%d:%H:%M"));
        } else if (unit === 'day') {
          axis = d3.axisBottom(x)
            .ticks(d3.timeDay.every(1))
            .tickFormat(d3.timeFormat("%b %d"));
        } else if (unit === 'week') {
          axis = d3.axisBottom(x)
            .ticks(d3.timeWeek.every(1))
            .tickFormat(d => "W" + d3.timeFormat("%b:%d")(d));
        } else if (unit === 'month') {
          axis = d3.axisBottom(x)
            .ticks(d3.timeMonth.every(1))
            .tickFormat(d3.timeFormat("%b"));
        } else { // year 
          axis = d3.axisBottom(x)
            .ticks(d3.timeYear.every(1))
            .tickFormat(d3.timeFormat("%Y"));
        }
        xAxisG.call(axis)
          .selectAll("text")
          .style("text-anchor", "end")
          .attr("transform", "rotate(-35)")
          .attr("dx", "-6")
          .attr("dy", "8")
          .style("cursor", "pointer")
          .on("click", (event, d) => {
            // navigate to clicked date (center that date/day) 
            navigateToDate(new Date(d));
          });
        // Function to navigate from x-axis tick click ‚Üí hours of that date
        function navigateToDate(clickedDate) {
          const startOfDay = new Date(clickedDate);
          startOfDay.setHours(0, 0, 0, 0);

          selectedDayISO = startOfDay.toISOString();
          currentUnit = 'hour';
          prepareAndDraw('hour', selectedDayISO);

          const btns = d3.selectAll(".time-buttons button");
          btns.classed("active", false);
          d3.select(".time-buttons button[data-unit='hour']").classed("active", true);
        }

        yAxisG.call(d3.axisLeft(y));
        y2AxisG.call(d3.axisRight(y2));
      }




      // line generator builder 
      const makeLine = (yScale) => d3.line()
        .defined(d => d && d.y !== null && d.y !== undefined && !isNaN(d.y))
        .x(d => x(new Date(d.x)))
        .y(d => yScale(d.y))
      //.curve(d3.curveMonotoneX); // smooth-ish 
      // === ZOOM BEHAVIOR === 
      let isPanEnabled = false; // Initial state: Pan disabled, Tooltip enabled 
      const zoomBehavior = d3.zoom()
        .scaleExtent([1, 32])
        .translateExtent([[0, 0], [width, height]])
        .extent([[0, 0], [width, height]])
        .filter(event => isPanEnabled) // ONLY pan if isPanEnabled is true 
        .on("zoom", zoomed);

      function zoomed(event) {
        currentXScale = event.transform.rescaleX(x);

        // Detect zoom scale
        const scale = event.transform.k;

        let axis;
        if (currentUnit === 'hour') {
          if (scale > 20) {
            // Very zoomed in ‚Üí show seconds
            axis = d3.axisBottom(currentXScale)
              .ticks(d3.timeSecond.every(10))
              .tickFormat(d3.timeFormat("%H:%M:%S"));
          } else if (scale > 5) {
            // Medium zoom ‚Üí show minutes
            axis = d3.axisBottom(currentXScale)
              .ticks(d3.timeMinute.every(5))
              .tickFormat(d3.timeFormat("%H:%M"));
          } else {
            // Default hourly ticks
            axis = d3.axisBottom(currentXScale)
              .ticks(d3.timeHour.every(1))
              .tickFormat(d3.timeFormat("%H:%M"));
          }
        } else if (currentUnit === 'day') {
          if (scale > 8) {
            axis = d3.axisBottom(currentXScale)
              .ticks(d3.timeHour.every(1))
              .tickFormat(d3.timeFormat("%b %d %H:%M"));
          } else {
            axis = d3.axisBottom(currentXScale)
              .ticks(d3.timeDay.every(1))
              .tickFormat(d3.timeFormat("%b %d"));
          }
        } else {
          // fallback: use default
          axis = d3.axisBottom(currentXScale);
        }

        xAxisG.call(axis)
          .selectAll("text")
          .style("text-anchor", "end")
          .attr("transform", "rotate(-35)")
          .attr("dx", "-6")
          .attr("dy", "8");
      }
      svg.call(zoomBehavior);

      // --- TOOLTIP FOCUS ELEMENTS --- 
      // Focus elements for the tooltip 
      const focus = mainG.append("g")
        .attr("class", "focus")
        .style("display", "none");
      // Vertical line that appears on hover 
      focus.append("line")
        .attr("class", "focus-line")
        .attr("y1", 0)
        .attr("y2", height)
        .attr("stroke", "#333")
        .attr("stroke-width", 1)
        .attr("stroke-dasharray", "3,3");
      // Circle marker for a specific line data point (uses room temp y-position) 

      const focusCircle = focus.append("circle")
        .attr("r", 5)
        .attr("fill", colorMap.room)
        .attr("stroke", "white")
        .attr("stroke-width", 1.5);
      // draw function that rebuilds lines & markers for given filtered arrays 

      function drawAll({ humidityData, roomData, setTData, outsideData, heaterData, overrideData, workingData }) {
        // clear existing content 
        linesLayer.selectAll("*").remove();
        markersLayer.selectAll("*").remove();
        // create datasets array with metadata order (same order used for legend indexes) 
        const datasets = [
          { key: "humidity", name: "Humidity (%)", data: humidityData, color: colorMap.humidity, yScale: y2, type: "line" },
          { key: "room", name: "Room Temp (¬∞C)", data: roomData, color: colorMap.room, yScale: y, type: "line" },
          { key: "setT", name: "Set Temp (¬∞C)", data: setTData, color: colorMap.setT, yScale: y, type: "line" },
          { key: "outside", name: "Outside Temp (¬∞C)", data: outsideData, color: colorMap.outside, yScale: y, type: "line" },
        ];

        datasets.forEach(ds => {
          const path = linesLayer.append("path")
            .datum(ds.data)
            .attr("class", `line line-${ds.key}`)
            .attr("fill", "none")
            .attr("stroke", ds.color)
            .attr("stroke-width", 2.2)
            .attr("d", makeLine(ds.yScale));

          // hide immediately if legend toggled off 
          if (!visibility[ds.key]) path.style("display", "none");
          if (isInitialLoad) { // Only animate on first load 
            // animate stroke-draw 
            const totalLen = path.node().getTotalLength();
            path.attr("stroke-dasharray", totalLen + " " + totalLen)
              .attr("stroke-dashoffset", totalLen)
              .transition()
              .duration(10000) // preserved slow drawing for visibility 
              .ease(d3.easeLinear)
              .attr("stroke-dashoffset", 0)

          }
        });
        // ‚úÖ Call markers with the datasets
        drawMarkers(heaterData, overrideData, workingData);
      }

      // markers drawing 
      function drawMarkers(heaterData, overrideData, workingData) {

        // heater triangles
        markersLayer.selectAll(".heater-marker")
          .data(heaterData)
          .enter()
          .append("path")
          .attr("class", "heater-marker")
          .attr("d", d3.symbol().type(d3.symbolTriangle).size(110))
          .attr("transform", d => `translate(${x(new Date(d.x))},${y(d.y)}) rotate(${d.state ? 0 : 180})`)
          .attr("fill", d => d.state ? "green" : "red");

        // override diamonds
        markersLayer.selectAll(".override-marker")
          .data(overrideData)
          .enter()
          .append("path")
          .attr("class", "override-marker")
          .attr("d", d3.symbol().type(d3.symbolDiamond).size(130))
          .attr("transform", d => `translate(${x(new Date(d.x))},${y(d.y)})`)
          .attr("fill", colorMap.override);

        // working dots
        markersLayer.selectAll(".working-group")
          .data(workingData)
          .enter()
          .append("circle")
          .attr("class", "working-group")
          .attr("r", 4)
          .attr("cx", d => x(new Date(d.x)))
          .attr("cy", d => y(d.y))
          .attr("fill", colorMap.working);

        // remove/hide according to legend state
        if (!visibility.heater) markersLayer.selectAll(".heater-marker").style("display", "none");
        if (!visibility.override) markersLayer.selectAll(".override-marker").style("display", "none");
        if (!visibility.working) markersLayer.selectAll(".working-group").style("display", "none");
      }

      const legendIconMap = {
        humidity: 'üíß', // Water drop for humidity 
        room: 'üè†', // House for room temperature 
        setT: 'üéØ', // Target for set temperature/goal 
        outside: '‚òÅÔ∏è', // Cloud for outside temperature 
        heater: 'üî•',  // Flame for heater state change (on/off) 
        override: '‚ö†Ô∏è', // Warning/Alert for override active 
        working: '‚öôÔ∏è' // Gear/Tool for working/heating activity 
      };

      const legendItems = [
        { key: "humidity", label: "Humidity", color: colorMap.humidity, icon: legendIconMap.humidity },
        { key: "room", label: "Room Temp", color: colorMap.room, icon: legendIconMap.room },
        { key: "setT", label: "Set Temp", color: colorMap.setT, icon: legendIconMap.setT },
        { key: "outside", label: "Outside Temp", color: colorMap.outside, icon: legendIconMap.outside },
        { key: "heater", label: "Heater State Change", color: colorMap.heater, icon: legendIconMap.heater },
        { key: "override", label: "Override Active", color: colorMap.override, icon: legendIconMap.override },
        { key: "working", label: "Working + Heating", color: colorMap.working, icon: legendIconMap.working }
      ];

      // --- legend (build once and wire toggles) 
      const legendContainer = d3.select("#custom-legend");
      legendItems.forEach(item => {
        const div = legendContainer.append("div").attr("class", "legend-item").attr("data-key", item.key);
        div.append("span").attr("class", "legend-icon").style("color", item.color).html(item.icon); // Insert the emoji/icon 
        div.append("span").text(item.label);
        div.on("click", function () {
          const key = item.key;
          visibility[key] = !visibility[key];
          d3.select(this).classed("inactive", !visibility[key]);
          // show/hide related elements 
          if (["humidity", "room", "setT", "outside"].includes(key)) {
            // hide/show line and dots 
            mainG.selectAll(`.line-${key}`).style("display", visibility[key] ? null : "none");
            mainG.selectAll(`.dot-${key}`).style("display", visibility[key] ? null : "none");
          } else if (key === "heater") {
            mainG.selectAll(".heater-marker").style("display", visibility[key] ? null : "none");
          } else if (key === "override") {
            mainG.selectAll(".override-marker").style("display", visibility[key] ? null : "none");
          } else if (key === "working") {
            mainG.selectAll(".working-group").style("display", visibility[key] ? null : "none");
          }
        });
      });

      // --- initial render using 'day' default 
      let currentUnit = 'day';
      //where we filter datasets for hour button 
      function prepareAndDraw(unit, dayIso = null) {
        // slice data based on unit and (for hours) selected day 
        // For Hours: filter datasets to only that day 
        let humidityData = humidity.slice(), roomData = room.slice(), setTData = setT.slice(), outsideData = outside.slice();
        let heaterData = heaterMarkers.slice(), overrideData = overrideMarkers.slice(), workingData = workingDots.slice();

        if (unit === 'hour' && dayIso) {
          // dayIso is midnight ISO string: keep only points within that day 
          const start = new Date(dayIso);
          const end = new Date(start.getTime() + 24 * 3600 * 1000);
          const inRange = d => (new Date(d.x) >= start && new Date(d.x) <= end);
          humidityData = humidityData.filter(inRange);
          roomData = roomData.filter(inRange);
          setTData = setTData.filter(inRange);
          outsideData = outsideData.filter(inRange);
          heaterData = heaterData.filter(inRange);
          overrideData = overrideData.filter(inRange);
          workingData = workingData.filter(inRange);
        } else {
          x.domain(d3.extent(allPoints, d => new Date(d.x)));
        }
        // update x domain for the selected view: 
        // for hour w/ day => domain to that 24h range 
        if (unit === 'hour' && dayIso) {
          const start = new Date(dayIso);
          const end = new Date(start.getTime() + 24 * 3600 * 1000);
          x.domain([start, end]);
        } else {
          x.domain(d3.extent([...humidityData, ...roomData, ...setTData, ...outsideData,].map(d => new Date(d.x))));
        }


        currentXScale = x.copy();   // ‚úÖ keep tooltip aligned
        // render axes based on unit 
        renderAxes(unit, dayIso);
        // draw everything 
        drawAll({
          humidityData, roomData, setTData, outsideData, heaterData, overrideData, workingData
        });
      }
      // Initial call 
      prepareAndDraw(currentUnit, null);
      isInitialLoad = false;

      // --- TOOLTIP INTERACTION LOGIC --- 
      // D3 Bisector to find the closest data point in time 
      const bisectDate = d3.bisector(d => new Date(d.x)).left;
      // The function that runs when the mouse moves over the graph 
      function mousemove(event) {
        // Only continue if we have room data to reference the time 
        if (room.length === 0 || isPanEnabled) return; ¬†// Disable tooltip if pan is enabled 
        const [mx] = d3.pointer(event, mainG.node());
        const xDate = currentXScale.invert(mx); // Convert mouse X-position back to a Date 

        // Find the closest data point in the Room Temp array (used as primary time reference) 
        const i = bisectDate(room, xDate, 1);
        const d0 = room[i - 1];
        const d1 = room[i];
        // Choose the data point that's temporally closest to the mouse's X position 
        const d = (d1 && xDate - new Date(d0.x) > new Date(d1.x) - xDate) ? d1 : d0;
        if (!d) return;

        // --- Update Focus Elements --- 
        const xPos = currentXScale(new Date(d.x));
        const yPos = y(d.y);
        focus.attr("transform", `translate(${xPos}, 0)`);
        focusCircle.attr("cy", yPos);

        // --- Retrieve values for the other datasets at the same timestamp (d.x) --- 
        const humidityPoint = humidity.find(p => p.x === d.x);
        const setPoint = setT.find(p => p.x === d.x);
        const working = setT.find(p => p.x === d.x);

        // **FIXED**: Use bisector for outside data to find the closest point in time 
        const iOutside = d3.bisector(d => new Date(d.x)).left(outside, xDate, 1);
        const dOutside0 = outside[iOutside - 1];
        const dOutside1 = outside[iOutside];
        const outsidePoint = (dOutside1 && xDate - new Date(dOutside0.x) > new Date(dOutside1.x) - xDate) ? dOutside1 : dOutside0;

        // **FIXED**: Use bisector for working data to find the closest point in time 
        const iWorking = d3.bisector(d => new Date(d.x)).left(workingDots, xDate, 1);
        const dWorking0 = workingDots[iWorking - 1];
        const dWorking1 = workingDots[iWorking];
        const workingPoint = (dWorking1 && xDate - new Date(dWorking0.x) > new Date(dWorking1.x) - xDate) ? dWorking1 : dWorking0;

        const isWorkingHeating = d.raw.working_hours === 'true' && d.raw.heating === 'true';
        const isHeatingOn = d.raw.heating === 'true';
        let tooltipContent = `<div style="font-weight:bold">${d3.timeFormat("%b %d, %H:%M")(new Date(d.x))}</div>`;

        // 1. Room Temp (Primary)
        if (visibility.room) {
          const heaterStatus = d.raw.heating === 'true' ? ' ON' : 'OFF';
          const flameIcon = isHeatingOn ? 'üî•' : 'üíß'; // Flaming/Water Drop icon 
          const statusColor = isHeatingOn ? 'green' : 'red';
          tooltipContent += `<div><span style="color:${colorMap.room};">&#9679;</span> Room Temp: ${d.y.toFixed(1)} ¬∞C</div>`;
          // New Animated/Iconic Status Line 
          tooltipContent += `<div style="font-size:14px;">${flameIcon}Heater: ${heaterStatus}</div>`;
        }

        if (visibility.working && isWorkingHeating) {
          tooltipContent += `<div><span style="color:${colorMap.working};">&#9679;</span> Working + Heating Active</div>`;
        }

        // 2. Set Temp 
        if (visibility.setT && setPoint) {
          tooltipContent += `<div><span style="color:${colorMap.setT};">&#9679;</span> Set Temp: ${setPoint.y.toFixed(1)} ¬∞C</div>`;
        }
        // 3. Outside Temp 
        if (visibility.outside && outsidePoint) {
          tooltipContent += `<div><span style="color:${colorMap.outside};">&#9679;</span> Outside Temp: ${outsidePoint.y.toFixed(1)} ¬∞C</div>`;
        }
        // 4. Humidity 
        if (visibility.humidity && humidityPoint) {
          tooltipContent += `<div><span style="color:${colorMap.humidity};">&#9679;</span> Humidity: ${humidityPoint.y.toFixed(0)} %</div>`;
        }
        // Position and show the tooltip 
        tooltip.style("opacity", 1)
          .html(tooltipContent)
          .style("left", (event.pageX + 10) + "px")
          .style("top", (event.pageY - 28) + "px");
      }
      // Function to hide elements on mouseout 
      function mouseout() {
        if (isPanEnabled) return; // Keep focus elements hidden if pan is enabled 
        focus.style("display", "none");
        tooltip.style("opacity", 0);
      }
      // Attach the listeners to a transparent rectangle covering the chart area 
      mainG.append("rect")
        .attr("class", "overlay")
        .attr("width", width)
        .attr("height", height)
        .style("fill", "none")
        .style("pointer-events", "all") // Crucial for capturing events 
        .on("mouseover", () => { if (!isPanEnabled) focus.style("display", null); })
        .on("mouseout", mouseout)
        .on("mousemove", mousemove);
      // --- END TOOLTIP INTERACTION LOGIC --- 

      // --- time buttons behavior moving fromt d-h h-d 
      const btns = d3.selectAll(".time-buttons button");
      btns.on("click", function () {
        btns.classed("active", false);
        d3.select(this).classed("active", true);
        const unit = d3.select(this).attr("data-unit");
        currentUnit = unit;
        if (unit === 'hour') { ¬†//pick the selected day (if available) ‚Äî default to first date from recordDates  
          const day = selectedDayISO || recordDates[0];
          if (!day) {
            alert("No day data available in data.json for 'Hours' view.");
            return;
          }
          prepareAndDraw('hour', day);
        } else {
          prepareAndDraw(unit, null);
        }

      });

      // --- DATE PICKER EVENT LISTENER (NEW) --- 
      d3.select("#dataDate").on("change", function () {
        const selectedDateISO = this.value; // Format: YYYY-MM-DD 
        if (selectedDateISO) {
          // This logic triggers the zoom-in to the specific day 
          // The 'day' is passed as dayIso to prepareAndDraw 
          currentUnit = 'hour';
          prepareAndDraw('hour', selectedDateISO);
          // Update the active time button to 'Hours' 
          const btns = d3.selectAll(".time-buttons button");
          btns.classed("active", false);
          d3.select(".time-buttons button[data-unit='hour']").classed("active", true);
        }
      });

      window.zoomBy = (factor) => {
        svg.transition().call(zoomBehavior.scaleBy, factor);
      };

      window.resetZoom = () => {
        svg.transition().duration(600).call(zoomBehavior.transform, d3.zoomIdentity);
      };
      // download svg 
      window.downloadSVG = () => {
        const serializer = new XMLSerializer();
        const source = serializer.serializeToString(svg.node());
        const blob = new Blob([source], { type: "image/svg+xml;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url; a.download = "chart.svg"; a.click();
        URL.revokeObjectURL(url);
      };
      // expose setTimeUnit for older usage if needed 
      window.setTimeUnit = (unit) => {
        const targetButton = d3.select(`.time-buttons button[data-unit='${unit}']`);
        btns.classed("active", false);
        targetButton.classed("active", true);
        currentUnit = unit;
        if (unit === 'hour') {
          const day = selectedDayISO || recordDates[0];
          prepareAndDraw('hour', day);
        } else {
          prepareAndDraw(unit, null);
        }
      };
      // helper: when user wants Hours for a particular date, you can set window.selectedDayISO = "<ISO midnight>" then call setTimeUnit('hour') 
      window.selectDayForHours = (isoMidnightString) => {
        if (!isoMidnightString) return;
        selectedDayISO = isoMidnightString;
        setTimeUnit('hour');
      };
    })();
  </script>
</body>

</html>